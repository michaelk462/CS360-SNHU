# CS360-SNHU
## Briefly summarize the requirements and goals of the app you developed. What user needs was this app designed to address?
The Weight Tracker app was created to assist users in monitoring their daily body weight over time and reaching a personal fitness goal. Quite often, people who are on a weight loss or maintenance journey have a hard time sticking to the tracking habit because the existing solutions are either too complicated or require internet connection. This app fulfills this need by offering a simple, offline, persistent daily weight log along with goal setting and SMS notification features, all wrapped in one lightweight Android app.
## What screens and features were necessary to support user needs and produce a user-centered UI for the app? How did your UI designs keep users in mind? Why were your designs successful?
The main user needs which this app was created to satisfy are the capability of recording a weight entry for any particular date, seeing all entries at a glance, modifying or deleting entries when necessary, setting a personal goal weight, and getting a message alert at the perfect time via SMS. The app has three parts: a login screen, a weight entry screen, and a dialog interface that gives users the ability to add, edit, and set goals. Users can register or log in to an account, and their credentials are stored in SQLite for data persistence. The Weight Display screen shows the date and weight entries using a RecyclerView grid and features buttons for editing and deleting the records. Underneath, it displays a banner showing the goal weight. A floating action button is available for users to add new entries in no time. The "Set Goal Weight" dialog, in the options menu, prepopulates the previous goals and saves any changes to align with future entries. The user interface of the app aims to be simple and user-friendly by only giving out the necessary information and by being very easy to use.
## How did you approach the process of coding your app? What techniques or strategies did you use? How could those techniques or strategies be applied in the future?
I separated development into different layers: database logic in both WeightDatabaseHelper.java and WeightDAO.java, UI logic in the Activity classes, and SMS functionality in SmsNotificationHelper.java. Such compartmentalization made the process of identifying bugs so much easier, and there was no wide ripple effect across the components. To maintain a clean and reusable data layer, I have implemented explicit CRUD methods in the DAO, which is a pattern that can be used for any future Android app requiring local storage.
## How did you test to ensure your code was functional? Why is this process important, and what did it reveal?
The Android Emulator was the primary test platform during development. After each major code commit, the application was rebuilt and tested in order to confirm that the new features worked as intended. All the main features, such as user registration, login, record creation, and the display of data grid functionality, were subjected to in-depth testing for bugs and proper operation. During this process, a few very subtle but important issues were uncovered through experimentation, e.g., differences in view IDs between a layout file and an Android Java adapter can cause the app to crash at runtime without a compile-time error.
## Consider the full app design and development process from initial planning to finalization. Where did you have to innovate to overcome a challenge?
A key challenge was implementing SMS notifications due to differences in SmsManager across Android versions. The solution involved checking and updating the code to handle SMS notification retrieval methods based on system version, after reviewing the developer documentation. This approach manages features that change between API levels.
## In what specific component of your mobile app were you particularly successful in demonstrating your knowledge, skills, and experience?
The app effectively demonstrates SQLite best practices by separating schema setup (WeightDatabaseHelper) from data operations (WeightDAO). Parameterized queries reduce SQL injection risk, and user and weight records are stored in normalized tables without unnecessary complexity. It supports all basic CRUD operations and preserves data even after logout or a device reboot. The organized structure aligns with Android architecture and sound database design, making future expansion straightforward.
